#include <SPI.h>
#include <Ethernet.h>
#include <Wire.h>

#define myrtc 0x68

byte mac[] = { 0x90, 0xA2, 0xDA, 0xDE, 0x9E, 0x74 };
char server[] = "data.sparkfun.com";
IPAddress ip(10,0,1,116);


EthernetClient client;

char *dow[]={" ","MON","TUE","WED","THU","FRI","SAT","SUN"};
char *mode[]={"HR","AM","PM"};
int dd,mm,yy,day,hh,mins,ss,mde;


const String publicKey = "EJQAE2b9r3CAKAqgXvZr";
const String privateKey = "dqRmM7yzY1UBdBrEnqmN";

float temp = 0;
float light = 0;
float humid =0;
float pir = 0;
float rain = 0;

void setup() {
  Serial.begin(9600);
  setupEthernet();
  Wire.begin();
  Serial.println(F("=========== Ready to Stream ==========="));
}

void loop() {
  Serial.println("Posting");
  postData();
  delay(30000);
}  
  
void postData() {
  temp = analogRead(0);
  temp = temp*0.488;
  //Serial.print("Temp ");
  //Serial.println(temp);
  
  light = analogRead(1);
  //Serial.print("Light ");
  //Serial.println(light);

  humid = analogRead(2);
  humid = humid*5;
  humid = humid/1024;
  humid = humid*90;
  humid = humid/2.97;
  //Serial.print("Humidity ");
  //Serial.println(humid);
  
  pir = analogRead(3);
  //Serial.print("pir ");
  //Serial.println(pir);
  
  rain = analogRead(4);
  //Serial.print("rain ");
  //Serial.println(rain);
   get_time();
  if (client.connect(server, 80))
  {
    client.print("GET /input/");
    client.print(publicKey);
    client.print("?private_key=");
    client.print(privateKey);
    client.print("&");
    client.print("_timestamp=");
    client.print(dd);
    client.print("/");
    client.print(mm);
    client.print("/");
    client.print(yy);
    client.print("%20"); 
    client.print(dow[day]);
    client.print("%20");
    client.print(hh);
    client.print(":"); 
    client.print(mins);
    client.print(":");
    client.print(ss);
    client.print("%20");
    client.print(mode[mde]); 
    client.print("&");
    client.print("humid=");
    client.print(humid);
    client.print("&");
    client.print("light=");
    client.print(light);
    client.print("&");
    client.print("pir=");
    client.print(pir);
    client.print("&");
    client.print("rain=");
    client.print(rain);
    client.print("&");
    client.print("temp=");
    client.print(temp);
    
    client.println(" HTTP/1.1");
    client.print("Host: ");
    client.println(server);
    client.println("Connection: close");
    client.println();
    Serial.println("Post Successful!!");
  }
  else
  {
    Serial.println(F("Connection failed"));
  } 

  // Check for a response from the server, and route it
  // out the serial port.
 while (client.connected())
 {
  if ( client.available() )
 {
 char c = client.read();
   Serial.print(c);
 }      
 }
 Serial.println();
  client.stop();  
}
  
void setupEthernet()
{
  //Serial.println("Setting up Ethernet...");
  if (Ethernet.begin(mac) == 0) {
    //Serial.println(F("Failed to configure Ethernet using DHCP"));
    Ethernet.begin(mac, ip);
  }
  //Serial.print("My IP address: ");
  //Serial.println(Ethernet.localIP());
  delay(1000);
}

void get_time()
{
  Wire.beginTransmission(myrtc); // Initialise transmission to the myrtc I2C address
  Wire.write(0x00); // Write the value of the register to start with, 0 in this case represented in BCD format
  Wire.endTransmission(); // end the transmission with the I2C device
  Wire.requestFrom(myrtc, 7);  // Now ask the I2C device for 7 Bytes of Data // This corresponds to the values of the 7 registers starting with the 0th register 

  ss = bcd_to_dec(Wire.read()); // The first read will retrieve the value from the register address 0x00 or the seconds register, this is in the BCD format, convert this back to decimal
  mins = bcd_to_dec(Wire.read());// The second read will retrieve the value from the register address 0x01 or the minutes register, this is in the BCD format, convert this back to decimal
  hh = Wire.read();// The third read will retrieve the value from the hours register, this value needs to be processed for the 24/12 hr mode

  // Check of if the BCD hours value retrieved is greater than 35 (this indicates that the hours is in 12 hour mode
  // 35 is the maximum BCD value possible in the 24hr mode
  if(hh > 35) 
  {
    hh = hh - 64; // in the 12 Hours Mode the 12 hour mode bit (6th bit) is set to high, so we need to subtract 2^6 from our hours value
    if(hh > 32)// Now check if the hour value is greater than 32 (2^5 = 32) (this indicates that PM bit (5th bit) is high)
    {
      mde = 2; // Set the mde variable to indicate PM
      hh = hh-32; // subtract 32 from the hours value 
    }
    else // if the hour value is less than 32 it means that its in the AM mode
    {
      mde = 1; // Set the mde variable to indicate AM
    }   
  }
  else // if the 12 hour mode bit was not set, then the hour is in the 24 hour mode
  {
    mde = 0; // Set the mde variable to indicate 24 Hours
  }

  hh = bcd_to_dec(hh); // Convert the final hour value from BCD to decimal and store it back into the same variable
  day = bcd_to_dec(Wire.read());// The fourth read will retrieve the value from the register address 0x03 or the day register, this is in the BCD format, convert this back to decimal
  dd = bcd_to_dec(Wire.read());// The fifthread will retrieve the value from the register address 0x04 or the date register, this is in the BCD format, convert this back to decimal
  mm = bcd_to_dec(Wire.read());// The sixth read will retrieve the value from the register address 0x05 or the month register, this is in the BCD format, convert this back to decimal
  yy = bcd_to_dec(Wire.read());// The seventh read will retrieve the value from the register address 0x06 or the year register, this is in the BCD format, convert this back to decimal

}

int dec_to_bcd(int dec)
{
  return dec/10*16 + (dec%10);
}

int bcd_to_dec(int bcd)
{
  return bcd/16*10 + (bcd%16);
}
